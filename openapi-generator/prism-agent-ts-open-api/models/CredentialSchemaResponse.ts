/* tslint:disable */
/* eslint-disable */
/**
 * Prism Agent
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
import type { Proof } from './Proof';
import {
    ProofFromJSON,
    ProofFromJSONTyped,
    ProofToJSON,
} from './Proof';

/**
 * 
 * @export
 * @interface CredentialSchemaResponse
 */
export interface CredentialSchemaResponse {
    /**
     * Globally unique id of the credential schema.It's composed from the bytes of the string that contain the `author`, `name`, and `version` values.The string format looks like the resource identifier: `author`/`id`?version=`version`
     * @type {string}
     * @memberof CredentialSchemaResponse
     */
    guid: string;
    /**
     * A locally unique identifier to address the schema. UUID is generated by the backend.
     * @type {string}
     * @memberof CredentialSchemaResponse
     */
    id: string;
    /**
     * Resource id of the credential schema. Contains the `author`'s DID, `id` and `version` fields.
     * @type {string}
     * @memberof CredentialSchemaResponse
     */
    longId?: string;
    /**
     * A human-readable name for the credential schema. A piece of Metadata.
     * @type {string}
     * @memberof CredentialSchemaResponse
     */
    name: string;
    /**
     * Denotes the revision of a given Credential Schema. It should follow semantic version convention to describe the impact of the schema evolution.
     * @type {string}
     * @memberof CredentialSchemaResponse
     */
    version: string;
    /**
     * Tokens that allow to lookup and filter the credential schema records.
     * @type {Array<string>}
     * @memberof CredentialSchemaResponse
     */
    tags?: Array<string>;
    /**
     * A human-readable description of the credential schema
     * @type {string}
     * @memberof CredentialSchemaResponse
     */
    description: string;
    /**
     * This field resolves to a JSON schema with details about the schema metadata that applies to the schema. A piece of Metadata.
     * @type {string}
     * @memberof CredentialSchemaResponse
     */
    type: string;
    /**
     * Valid JSON Schema where the Credential Schema data fields are defined. A piece of Metadata
     * @type {any}
     * @memberof CredentialSchemaResponse
     */
    schema: any | null;
    /**
     * DID of the identity which authored the credential schema. A piece of Metadata.
     * @type {string}
     * @memberof CredentialSchemaResponse
     */
    author: string;
    /**
     * [RFC3339](https://www.rfc-editor.org/rfc/rfc3339) date on which the credential schema was created. A piece of Metadata.
     * @type {Date}
     * @memberof CredentialSchemaResponse
     */
    authored: Date;
    /**
     * 
     * @type {Proof}
     * @memberof CredentialSchemaResponse
     */
    proof?: Proof;
    /**
     * A string that identifies the type of resource being returned in the response.
     * @type {string}
     * @memberof CredentialSchemaResponse
     */
    kind: string;
    /**
     * The URL that uniquely identifies the resource being returned in the response.
     * @type {string}
     * @memberof CredentialSchemaResponse
     */
    self: string;
}

/**
 * Check if a given object implements the CredentialSchemaResponse interface.
 */
export function instanceOfCredentialSchemaResponse(value: object): boolean {
    let isInstance = true;
    isInstance = isInstance && "guid" in value;
    isInstance = isInstance && "id" in value;
    isInstance = isInstance && "name" in value;
    isInstance = isInstance && "version" in value;
    isInstance = isInstance && "description" in value;
    isInstance = isInstance && "type" in value;
    isInstance = isInstance && "schema" in value;
    isInstance = isInstance && "author" in value;
    isInstance = isInstance && "authored" in value;
    isInstance = isInstance && "kind" in value;
    isInstance = isInstance && "self" in value;

    return isInstance;
}

export function CredentialSchemaResponseFromJSON(json: any): CredentialSchemaResponse {
    return CredentialSchemaResponseFromJSONTyped(json, false);
}

export function CredentialSchemaResponseFromJSONTyped(json: any, ignoreDiscriminator: boolean): CredentialSchemaResponse {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'guid': json['guid'],
        'id': json['id'],
        'longId': !exists(json, 'longId') ? undefined : json['longId'],
        'name': json['name'],
        'version': json['version'],
        'tags': !exists(json, 'tags') ? undefined : json['tags'],
        'description': json['description'],
        'type': json['type'],
        'schema': json['schema'],
        'author': json['author'],
        'authored': (new Date(json['authored'])),
        'proof': !exists(json, 'proof') ? undefined : ProofFromJSON(json['proof']),
        'kind': json['kind'],
        'self': json['self'],
    };
}

export function CredentialSchemaResponseToJSON(value?: CredentialSchemaResponse | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'guid': value.guid,
        'id': value.id,
        'longId': value.longId,
        'name': value.name,
        'version': value.version,
        'tags': value.tags,
        'description': value.description,
        'type': value.type,
        'schema': value.schema,
        'author': value.author,
        'authored': (value.authored.toISOString()),
        'proof': ProofToJSON(value.proof),
        'kind': value.kind,
        'self': value.self,
    };
}

